<HTML>
<HEAD><META name="HTML-Generator" content="Dymola"><TITLE>ModelicaAdditions</TITLE></HEAD>
<BODY><P>
<H2><A NAME="ModelicaAdditions.MultiBody.Interfaces"></A><A HREF="ModelicaAdditions_MultiBody.html#ModelicaAdditions.MultiBody"
>ModelicaAdditions.MultiBody</A>.Interfaces</H2>
<B>Connectors and partial models for 3D mechanical components</B>
<P>
<A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces.Frame"
><IMG SRC="ModelicaAdditions.MultiBody.Interfaces.FrameI.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.Frame" WIDTH=80  HEIGHT=80 ></A>
<A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces.Frame_a"
><IMG SRC="ModelicaAdditions.MultiBody.Interfaces.Frame_aI.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.Frame_a" WIDTH=80  HEIGHT=80 ></A>
<A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces.Frame_b"
><IMG SRC="ModelicaAdditions.MultiBody.Interfaces.Frame_bI.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.Frame_b" WIDTH=80  HEIGHT=80 ></A>
<A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces.OneFrame_a"
><IMG SRC="ModelicaAdditions.MultiBody.Interfaces.OneFrame_aI.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.OneFrame_a" WIDTH=80  HEIGHT=80 ></A>
<A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces.OneFrame_b"
><IMG SRC="ModelicaAdditions.MultiBody.Interfaces.OneFrame_bI.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.OneFrame_b" WIDTH=80  HEIGHT=80 ></A>
<A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces.TwoTreeFrames"
><IMG SRC="ModelicaAdditions.MultiBody.Interfaces.TwoTreeFramesI.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.TwoTreeFrames" WIDTH=80  HEIGHT=80 ></A>
<A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces.TwoNoTreeFrames"
><IMG SRC="ModelicaAdditions.MultiBody.Interfaces.TwoNoTreeFramesI.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.TwoNoTreeFrames" WIDTH=80  HEIGHT=80 ></A>
<A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces.FrameBase"
><IMG SRC="ModelicaAdditions.MultiBody.Interfaces.FrameBaseI.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.FrameBase" WIDTH=80  HEIGHT=80 ></A>
<A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces.BodyBase"
><IMG SRC="ModelicaAdditions.MultiBody.Interfaces.BodyBaseI.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.BodyBase" WIDTH=80  HEIGHT=80 ></A>
<A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces.Interact"
><IMG SRC="ModelicaAdditions.MultiBody.Interfaces.InteractI.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.Interact" WIDTH=80  HEIGHT=80 ></A>
<A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces.Interact2"
><IMG SRC="ModelicaAdditions.MultiBody.Interfaces.Interact2I.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.Interact2" WIDTH=80  HEIGHT=80 ></A>
<A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces.ExtForceBase"
><IMG SRC="ModelicaAdditions.MultiBody.Interfaces.ExtForceBaseI.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.ExtForceBase" WIDTH=80  HEIGHT=80 ></A>
<A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces.ExtTorqueBase"
><IMG SRC="ModelicaAdditions.MultiBody.Interfaces.ExtTorqueBaseI.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.ExtTorqueBase" WIDTH=80  HEIGHT=80 ></A>
<A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces.Force"
><IMG SRC="ModelicaAdditions.MultiBody.Interfaces.ForceI.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.Force" WIDTH=80  HEIGHT=80 ></A>
<A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces.LineForce"
><IMG SRC="ModelicaAdditions.MultiBody.Interfaces.LineForceI.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.LineForce" WIDTH=80  HEIGHT=80 ></A>
<A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces.TreeJoint"
><IMG SRC="ModelicaAdditions.MultiBody.Interfaces.TreeJointI.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.TreeJoint" WIDTH=80  HEIGHT=80 ></A>
<A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces.CutJoint"
><IMG SRC="ModelicaAdditions.MultiBody.Interfaces.CutJointI.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.CutJoint" WIDTH=80  HEIGHT=80 ></A>
<A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces.planarRotation"
><IMG SRC="ModelicaAdditions.MultiBody.Interfaces.planarRotationI.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.planarRotation" WIDTH=80  HEIGHT=80 ></A>
<A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces.axisRotation"
><IMG SRC="ModelicaAdditions.MultiBody.Interfaces.axisRotationI.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.axisRotation" WIDTH=80  HEIGHT=80 ></A>
<P><P>
<H3>Information</H3>
<PRE>
</PRE>
<p>
This package contains connectors and partial models for 3D mechanical
components.
</p>

<dl>
<dt><b>Main Author:</b>
<dd><a href="http://www.op.dlr.de/~otter/">Martin Otter</a><br>
    Deutsches Zentrum f&uuml;r Luft und Raumfahrt e.V. (DLR)<br>
    Institut f&uuml;r Robotik und Mechatronik<br>
    Postfach 1116<br>
    D-82230 Wessling<br>
    Germany<br>
    email: <A HREF="mailto:Martin.Otter@dlr.de">Martin.Otter@dlr.de</A><br>
</dl>
<br>

<p><b>Release Notes:</b></p>
<ul>
<li><i>April 5, 2000</i>
       by <a href="http://www.op.dlr.de/~otter/">Martin Otter</a>:<br>
       Realized.</li>
</ul>
<br>

<p><b>Copyright (C) 2000, DLR.</b></p>

<p><i>
The Modelica package is <b>free</b> software; it can be redistributed and/or modified
under the terms of the <b>Modelica license</b>, see the license conditions
and the accompanying <b>disclaimer</b> in the documentation of package
Modelica in file "Modelica/package.mo".
</i></p>
<PRE>
</PRE><P>
<HR>
<H2><IMG SRC="ModelicaAdditions.MultiBody.Interfaces.CutJointI.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.CutJoint" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="ModelicaAdditions.MultiBody.Interfaces.CutJoint"></A><A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces"
>ModelicaAdditions.MultiBody.Interfaces</A>.CutJoint</H2>
<B>Superclass of Cut-Joint classes</B><p>
<IMG SRC="ModelicaAdditions.MultiBody.Interfaces.CutJointD.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.CutJoint">
<H3>Information</H3>
<PRE></PRE>
<p>
A joint has two mechanical cuts which may move relative to each
other. It is a massless element in which no energy is stored.
Mathematically, a joint transforms the kinematic properties
of frame_a to frame_b and at the same time transforms
the force and torque acting on frame_b to frame_a.
</p>

<p>
A general multibody system with closed kinematic loops is handeled
by dividing the joints into two distinct sets: Tree-Joints and
Cut-Joints. After removal of all of the Cut-Joints, the resulting
system must have a tree-structure. Class CutJoint is used as
a superclass for Cut-Joints.
</p>

<p>
Subclasses of class CutJoint have to provide the (6-f) constraint
equations on position level, where
 f  are the number of degrees of freedom of the joint.
</p>
<PRE>
</PRE>
<H3>Modelica definition</H3>
<PRE>
partial model CutJoint &quot;Superclass of Cut-Joint classes&quot;
  extends <A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces.Interact2"
>MultiBody.Interfaces.Interact2</A>;
end CutJoint;
</PRE>
<HR>
<H2><IMG SRC="ModelicaAdditions.MultiBody.Interfaces.Frame_bI.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.Frame_b" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="ModelicaAdditions.MultiBody.Interfaces.Frame_b"></A><A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces"
>ModelicaAdditions.MultiBody.Interfaces</A>.Frame_b</H2>
<B>Frame b of a mechanical element</B><p>
<IMG SRC="ModelicaAdditions.MultiBody.Interfaces.Frame_bD.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.Frame_b">
<H3>Information</H3>
<PRE></PRE>
<p>
Frame b  of a mechanical element.
</p>

<p>
All mechanical components are always connected together at frames.
A frame is a coordinate system in the (mechanical) cut-plane of the
connection point. The variables of the cut-plane are defined
with respect to the corresponding frame_b and have the following meaning:
</p>

<pre>
Potential variables:
  S : Rotation matrix describing frame_b with respect to the inertial
      frame, i.e. if ha is vector h resolved in frame_b and h0 is
      vector h resolved in the inertial frame, h0 = S*ha.
  r0: Vector from the origin of the inertial frame to the origin
      of frame_a, resolved in the inertial frame in [m] !!! (note,
      that all other vector quantities are resolved in frame_a!!!).
  v : Absolute (translational) velocity of frame_a, resolved in a,
      in [m/s]:  v = transpose(S)*der(r0)
  w : Absolute angular velocity of frame_a, resolved in a,
      in [rad/s]  :  w = vec(transpose(S)*der(S));  Note, that
                   |   0 -w3  w2 |
         skew(w) = |  w3   0 -w1 | and w=vec(skew(w))
                   | -w2  w1   0 |
  a : Absolute translational acceleration of frame_b - gravity
      acceleration, resolved in a, in [m/s^2]:
          a = transpose(S)*( der(S*v) - ng*g )
      (ng,g are defined in model MultiBody.Parts.InertialSystem).
  z : Absolute angular acceleration of frame_a, resolved in a,
      in [rad/s^2]:  z = transpose(S)*der(S*w)

Flow variables:
  f : Resultant cut-force acting at the origin of frame_a,
      resolved in a, in [N].
  t : Resultant cut-torque with respect to the origin of frame_a,
      resolved in a, in [Nm].
</pre>
<HTML>
<PRE></PRE>
<H3>Modelica definition</H3>
<PRE>
connector Frame_b &quot;Frame b of a mechanical element&quot;
  output SIunits.Position r0[3]
    &quot;Position vector from inertial system to frame origin, resolved in inertial system&quot;
    ;
  Real S[3, 3]
    &quot;Transformation matrix from frame_a to inertial system&quot;;
  SIunits.Velocity v[3]
    &quot;Absolute velocity of frame origin, resolved in frame_a&quot;;
  SIunits.AngularVelocity w[3]
    &quot;Absolute angular velocity of frame_a, resolved in frame_a&quot;;
  SIunits.Acceleration a[3]
    &quot;Absolute acceleration of frame origin, resolved in frame_a&quot;;
  SIunits.AngularAcceleration z[3]
    &quot;Absolute angular acceleration of frame_a, resolved in frame_a&quot;;
  flow SIunits.Force f[3];
  flow SIunits.Torque t[3];
end Frame_b;
</PRE>
<HR>
<H2><IMG SRC="ModelicaAdditions.MultiBody.Interfaces.ExtForceBaseI.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.ExtForceBase" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="ModelicaAdditions.MultiBody.Interfaces.ExtForceBase"></A><A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces"
>ModelicaAdditions.MultiBody.Interfaces</A>.ExtForceBase</H2>
<B>Superclass of external forces</B><p>
<IMG SRC="ModelicaAdditions.MultiBody.Interfaces.ExtForceBaseD.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.ExtForceBase">
<H3>Information</H3>
<PRE></PRE>
<p>
An external force element exerts a force on frame_b,
resolved in frame_b. Force  fb (=-frame_b.f)  must be assigned a value.
</p>
<PRE>
</PRE>
<H3>Modelica definition</H3>
<PRE>
partial model ExtForceBase &quot;Superclass of external forces&quot;
  <A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces.Frame_a"
>MultiBody.Interfaces.Frame_a</A> frame_b;
equation
  frame_b.t = zeros(3);
end ExtForceBase;
</PRE>
<HR>
<H2><IMG SRC="ModelicaAdditions.MultiBody.Interfaces.ExtTorqueBaseI.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.ExtTorqueBase" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="ModelicaAdditions.MultiBody.Interfaces.ExtTorqueBase"></A><A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces"
>ModelicaAdditions.MultiBody.Interfaces</A>.ExtTorqueBase</H2>
<B>Superclass of external torques</B><p>
<IMG SRC="ModelicaAdditions.MultiBody.Interfaces.ExtTorqueBaseD.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.ExtTorqueBase">
<H3>Information</H3>
<PRE></PRE>
<p>
An external torque element exerts a torque on frame_b,
resolved in frame_b. Torque  tb (=-frame_b.t) must be assigned a value.
</p>
<PRE>
</PRE>
<H3>Modelica definition</H3>
<PRE>
partial model ExtTorqueBase &quot;Superclass of external torques&quot;
  <A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces.Frame_a"
>MultiBody.Interfaces.Frame_a</A> frame_b;
equation
  frame_b.f = zeros(3);
end ExtTorqueBase;
</PRE>
<HR>
<H2><IMG SRC="ModelicaAdditions.MultiBody.Interfaces.LineForceI.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.LineForce" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="ModelicaAdditions.MultiBody.Interfaces.LineForce"></A><A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces"
>ModelicaAdditions.MultiBody.Interfaces</A>.LineForce</H2>
<B>Superclass of line force elements</B><p>
<IMG SRC="ModelicaAdditions.MultiBody.Interfaces.LineForceD.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.LineForce">
<H3>Information</H3>
<PRE></PRE>
<p>
Superclass of line force elements.
</p>

<p>
A line force element exerts a force between the origin of
frame_a and the origin of frame_b. In subclasses of
this class the line force  <b>f</b>  is given as function of the
relative distance  <b>s</b>  between the origins of the two
cut-frames and its first derivative  <b>sd</b>.
The following parameters are defined:
</p>

<pre>
  sEps: When  sd ,  sdd ,  fa ,  fb  are calculated, a division by
        zero takes place, if the distance becomes zero. Therefore, for
        this calculation the modified distance  smod = max(s, sEps)
        is used.

Terminal variables:
  f    : The scalar value of the line force in [N].
           pulling  force: f > 0
           pressure force: f < 0
  s    : Distance in [m] (s >= 0).
  sd   : First  derivative of s in [m/s].
  sdd  : Second derivative of s in [m/s^2].
  na(3): Unit vector on the line from the origin of frame_a to
         the origin of frame_b, resolved in frame_a.
</pre>

<p>
<b>Note:</b><br>
Both frames of a force element have <b>always</b> to be connected at
frame_a of a joint, of a body or of the inertial system. It is not possible
to e.g. connect two force elements in series.
</p>
<PRE>

</PRE>
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>sEps</TD><TD>1.E-6</TD><TD>prevent zero-division if rel. distance s=0 [m]</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
model LineForce &quot;Superclass of line force elements&quot;
  extends <A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces.Interact2"
>MultiBody.Interfaces.Interact2</A>;
  parameter Real sEps=1.E-6
    &quot;prevent zero-division if rel. distance s=0 [m]&quot;;
  SIunits.Force f;
  SIunits.Position s;
  SIunits.Velocity sd;
  SIunits.Acceleration sdd;
  Real na[3];
  SIunits.Position smod;
equation
  s = sqrt(r_rela*r_rela);
  <I></I>
  <I>/*Determine velocity and acceleration, guard against zero distance*/</I>
  smod = max([s, sEps]);
  na = r_rela/smod;
  sd = na*v_rela;
  sdd = na*a_rela + (v_rela*v_rela - sd*sd)/smod;
  <I></I>
  <I>/*Determine forces/torques at frame_a and B*/</I>
  ta = zeros(3);
  tb = zeros(3);
  fa = -na*f;
  fb = S_rel*fa;
end LineForce;
</PRE>
<HR>
<H2><IMG SRC="ModelicaAdditions.MultiBody.Interfaces.FrameI.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.Frame" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="ModelicaAdditions.MultiBody.Interfaces.Frame"></A><A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces"
>ModelicaAdditions.MultiBody.Interfaces</A>.Frame</H2>
<B>Frame record of a mechanical element</B><p>
<IMG SRC="ModelicaAdditions.MultiBody.Interfaces.FrameD.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.Frame">
<H3>Information</H3>
<PRE></PRE>
<p>
Frame of a mechanical element.
</p>

<p>
All mechanical components are always connected together at frames.
A frame is a coordinate system in the (mechanical) cut-plane of the
connection point. The variables of the cut-plane are defined
with respect to the corresponding frame and have the following meaning:
</p>

<pre>
Potential variables:
  S : Rotation matrix describing frame with respect to the inertial
      frame, i.e. if ha is vector h resolved in the frame_and h0 is
      vector h resolved in the inertial frame, h0 = S*ha.
  r0: Vector from the origin of the inertial frame to the origin
      of frame_a, resolved in the inertial frame in [m] !!! (note,
      that all other vector quantities are resolved in frame_a!!!).
  v : Absolute (translational) velocity of frame_a, resolved in a,
      in [m/s]:  v = transpose(S)*der(r0)
  w : Absolute angular velocity of frame_a, resolved in a,
      in [rad/s]  :  w = vec(transpose(S)*der(S));  Note, that
                   |   0 -w3  w2 |
         skew(w) = |  w3   0 -w1 | and w=vec(skew(w))
                   | -w2  w1   0 |
  a : Absolute translational acceleration of frame - gravity
      acceleration, resolved in a, in [m/s^2]:
          a = transpose(S)*( der(S*v) - ng*g )
      (ng,g are defined in model MultiBody.Parts.InertialSystem).
  z : Absolute angular acceleration of frame_a, resolved in a,
      in [rad/s^2]:  z = transpose(S)*der(S*w)

Flow variables:
  f : Resultant cut-force acting at the origin of frame_a,
      resolved in a, in [N].
  t : Resultant cut-torque with respect to the origin of frame_a,
      resolved in a, in [Nm].
</pre>
<PRE>
</PRE>
<H3>Modelica definition</H3>
<PRE>
record Frame &quot;Frame record of a mechanical element&quot;
  SIunits.Position r0[3]
    &quot;Position vector from inertial system to frame origin, resolved in inertial system&quot;
    ;
  Real S[3, 3]
    &quot;Transformation matrix from frame_a to inertial system&quot;;
  SIunits.Velocity v[3]
    &quot;Absolute velocity of frame origin, resolved in frame_a&quot;;
  SIunits.AngularVelocity w[3]
    &quot;Absolute angular velocity of frame_a, resolved in frame_a&quot;;
  SIunits.Acceleration a[3]
    &quot;Absolute acceleration of frame origin, resolved in frame_a&quot;;
  SIunits.AngularAcceleration z[3]
    &quot;Absolute angular acceleration of frame_a, resolved in frame_a&quot;;
  flow SIunits.Force f[3];
  flow SIunits.Torque t[3];
  <I></I>
end Frame;
</PRE>
<HR>
<H2><IMG SRC="ModelicaAdditions.MultiBody.Interfaces.Frame_aI.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.Frame_a" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="ModelicaAdditions.MultiBody.Interfaces.Frame_a"></A><A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces"
>ModelicaAdditions.MultiBody.Interfaces</A>.Frame_a</H2>
<B>Frame a of a mechanical element</B><p>
<IMG SRC="ModelicaAdditions.MultiBody.Interfaces.Frame_aD.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.Frame_a">
<H3>Information</H3>
<PRE></PRE>
<p>
Frame a  of a mechanical element.
</p>

<p>
All mechanical components are always connected together at frames.
A frame is a coordinate system in the (mechanical) cut-plane of the
connection point. The variables of the cut-plane are defined
with respect to the corresponding frame_a and have the following meaning:
</p>

<pre>
Potential variables:
  S : Rotation matrix describing frame_a with respect to the inertial
      frame, i.e. if ha is vector h resolved in frame_a and h0 is
      vector h resolved in the inertial frame, h0 = S*ha.
  r0: Vector from the origin of the inertial frame to the origin
      of frame_a, resolved in the inertial frame in [m] !!! (note,
      that all other vector quantities are resolved in frame_a!!!).
  v : Absolute (translational) velocity of frame_a, resolved in a,
      in [m/s]:  v = transpose(S)*der(r0)
  w : Absolute angular velocity of frame_a, resolved in a,
      in [rad/s]  :  w = vec(transpose(S)*der(S));  Note, that
                   |   0 -w3  w2 |
         skew(w) = |  w3   0 -w1 | and w=vec(skew(w))
                   | -w2  w1   0 |
  a : Absolute translational acceleration of frame_a - gravity
      acceleration, resolved in a, in [m/s^2]:
          a = transpose(S)*( der(S*v) - ng*g )
      (ng,g are defined in model MultiBody.Parts.InertialSystem).
  z : Absolute angular acceleration of frame_a, resolved in a,
      in [rad/s^2]:  z = transpose(S)*der(S*w)

Flow variables:
  f : Resultant cut-force acting at the origin of frame_a,
      resolved in a, in [N].
  t : Resultant cut-torque with respect to the origin of frame_a,
      resolved in a, in [Nm].
</pre>

<PRE>
</PRE>
<H3>Modelica definition</H3>
<PRE>
connector Frame_a &quot;Frame a of a mechanical element&quot;
  input SIunits.Position r0[3]
    &quot;Position vector from inertial system to frame origin, resolved in inertial system&quot;
    ;
  Real S[3, 3]
    &quot;Transformation matrix from frame_a to inertial system&quot;;
  SIunits.Velocity v[3]
    &quot;Absolute velocity of frame origin, resolved in frame_a&quot;;
  SIunits.AngularVelocity w[3]
    &quot;Absolute angular velocity of frame_a, resolved in frame_a&quot;;
  SIunits.Acceleration a[3]
    &quot;Absolute acceleration of frame origin, resolved in frame_a&quot;;
  SIunits.AngularAcceleration z[3]
    &quot;Absolute angular acceleration of frame_a, resolved in frame_a&quot;;
  flow SIunits.Force f[3];
  flow SIunits.Torque t[3];
  <I></I>
end Frame_a;
</PRE>
<HR>
<H2><IMG SRC="ModelicaAdditions.MultiBody.Interfaces.OneFrame_aI.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.OneFrame_a" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="ModelicaAdditions.MultiBody.Interfaces.OneFrame_a"></A><A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces"
>ModelicaAdditions.MultiBody.Interfaces</A>.OneFrame_a</H2>
<B>Superclass of elements with ONE mechanical frame_a</B><p>
<IMG SRC="ModelicaAdditions.MultiBody.Interfaces.OneFrame_aD.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.OneFrame_a">
<H3>Information</H3>
<PRE></PRE>
<p>
Superclass of elements which have <b>one</b> mechanical frame,
which is called frame_a.
</p>
<PRE>
</PRE>
<H3>Modelica definition</H3>
<PRE>
partial model OneFrame_a
  &quot;Superclass of elements with ONE mechanical frame_a&quot;
protected
  Real Sa[3, 3](start=identity(3));
  SIunits.Position r0a[3];
  SIunits.Velocity va[3];
  SIunits.AngularVelocity wa[3];
  SIunits.Acceleration aa[3];
  SIunits.AngularAcceleration za[3];
  SIunits.Force fa[3];
  SIunits.Torque ta[3];
public
  <A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces.Frame_a"
>MultiBody.Interfaces.Frame_a</A> frame_a(
    S=Sa,
    r0=r0a,
    v=va,
    w=wa,
    a=aa,
    z=za,
    f=fa,
    t=ta);
end OneFrame_a;
</PRE>
<HR>
<H2><IMG SRC="ModelicaAdditions.MultiBody.Interfaces.OneFrame_bI.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.OneFrame_b" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="ModelicaAdditions.MultiBody.Interfaces.OneFrame_b"></A><A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces"
>ModelicaAdditions.MultiBody.Interfaces</A>.OneFrame_b</H2>
<B>Superclass of elements with ONE mechanical frame_b</B><p>
<IMG SRC="ModelicaAdditions.MultiBody.Interfaces.OneFrame_bD.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.OneFrame_b">
<H3>Information</H3>
<PRE>
Superclass of elements which have ONE mechanical frame,
which is called frame_b .
</PRE>
<H3>Modelica definition</H3>
<PRE>
partial model OneFrame_b
  &quot;Superclass of elements with ONE mechanical frame_b&quot;
protected
  Real Sb[3, 3](start=identity(3));
  SIunits.Position r0b[3];
  SIunits.Velocity vb[3];
  SIunits.AngularVelocity wb[3];
  SIunits.Acceleration ab[3];
  SIunits.AngularAcceleration zb[3];
  SIunits.Force fb[3];
  SIunits.Torque tb[3];
public
  <A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces.Frame_b"
>MultiBody.Interfaces.Frame_b</A> frame_b(
    S=Sb,
    r0=r0b,
    v=vb,
    w=wb,
    a=ab,
    z=zb,
    f=-fb,
    t=-tb);
end OneFrame_b;
</PRE>
<HR>
<H2><IMG SRC="ModelicaAdditions.MultiBody.Interfaces.TwoTreeFramesI.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.TwoTreeFrames" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="ModelicaAdditions.MultiBody.Interfaces.TwoTreeFrames"></A><A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces"
>ModelicaAdditions.MultiBody.Interfaces</A>.TwoTreeFrames</H2>
<B>Superclass of elements of the spanning tree with TWO frames</B><p>
<IMG SRC="ModelicaAdditions.MultiBody.Interfaces.TwoTreeFramesD.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.TwoTreeFrames">
<H3>Information</H3>
<PRE></PRE>
<p>
Superclass of elements which have <b>two</b> mechanical frames in the
spanning tree, which are called <b>frame_a</b> and
<b>frame_b</b>, respectively.

<p>
<b>Important</b><br>
frame_a of an element should <b>always</b> be connected to a frame_b.<br>
frame_b of an element should <b>always</b> be connected to a frame_a.
</p>
<PRE>

</PRE>
<H3>Modelica definition</H3>
<PRE>
partial model TwoTreeFrames
  &quot;Superclass of elements of the spanning tree with TWO frames&quot;
public
  constant Real PI=Modelica.Constants.pi;
protected
  Real Sa[3, 3](start=identity(3));
  SIunits.Position r0a[3];
  SIunits.Velocity va[3];
  SIunits.AngularVelocity wa[3];
  SIunits.Acceleration aa[3];
  SIunits.AngularAcceleration za[3];
  SIunits.Force fa[3];
  SIunits.Torque ta[3];
  Real Sb[3, 3](start=identity(3));
  SIunits.Position r0b[3];
  SIunits.Velocity vb[3];
  SIunits.AngularVelocity wb[3];
  SIunits.Acceleration ab[3];
  SIunits.AngularAcceleration zb[3];
  SIunits.Force fb[3];
  SIunits.Torque tb[3];
  <I></I>
public
  <A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces.Frame_a"
>MultiBody.Interfaces.Frame_a</A> frame_a(
    S=Sa,
    r0=r0a,
    v=va,
    w=wa,
    a=aa,
    z=za,
    f=fa,
    t=ta);
  <A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces.Frame_b"
>MultiBody.Interfaces.Frame_b</A> frame_b(
    S=Sb,
    r0=r0b,
    v=vb,
    w=wb,
    a=ab,
    z=zb,
    f=-fb,
    t=-tb);
end TwoTreeFrames;
</PRE>
<HR>
<H2><IMG SRC="ModelicaAdditions.MultiBody.Interfaces.TwoNoTreeFramesI.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.TwoNoTreeFrames" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="ModelicaAdditions.MultiBody.Interfaces.TwoNoTreeFrames"></A><A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces"
>ModelicaAdditions.MultiBody.Interfaces</A>.TwoNoTreeFrames</H2>
<B>Superclass of elements not part of the spanning tree (two frames)</B><p>
<IMG SRC="ModelicaAdditions.MultiBody.Interfaces.TwoNoTreeFramesD.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.TwoNoTreeFrames">
<H3>Information</H3>
<PRE></PRE>
<p>
Superclass of elements which have <b>two</b> mechanical frames,
which are called frame_a and frame_b, respectively.
Submodels of the class are not allowed to be part of the
spanning tree.
</p>
<PRE>
</PRE>
<H3>Modelica definition</H3>
<PRE>
partial model TwoNoTreeFrames
  &quot;Superclass of elements not part of the spanning tree (two frames)&quot;

public
  constant Real PI=Modelica.Constants.pi;
protected
  Real Sa[3, 3](start=identity(3));
  SIunits.Position r0a[3];
  SIunits.Velocity va[3];
  SIunits.AngularVelocity wa[3];
  SIunits.Acceleration aa[3];
  SIunits.AngularAcceleration za[3];
  SIunits.Force fa[3];
  SIunits.Torque ta[3];
  Real Sb[3, 3](start=identity(3));
  SIunits.Position r0b[3];
  SIunits.Velocity vb[3];
  SIunits.AngularVelocity wb[3];
  SIunits.Acceleration ab[3];
  SIunits.AngularAcceleration zb[3];
  SIunits.Force fb[3];
  SIunits.Torque tb[3];
  <I></I>
public
  <A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces.Frame_a"
>MultiBody.Interfaces.Frame_a</A> frame_a(
    S=Sa,
    r0=r0a,
    v=va,
    w=wa,
    a=aa,
    z=za,
    f=fa,
    t=ta);
  <A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces.Frame_a"
>MultiBody.Interfaces.Frame_a</A> frame_b(
    S=Sb,
    r0=r0b,
    v=vb,
    w=wb,
    a=ab,
    z=zb,
    f=-fb,
    t=-tb);
end TwoNoTreeFrames;
</PRE>
<HR>
<H2><IMG SRC="ModelicaAdditions.MultiBody.Interfaces.FrameBaseI.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.FrameBase" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="ModelicaAdditions.MultiBody.Interfaces.FrameBase"></A><A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces"
>ModelicaAdditions.MultiBody.Interfaces</A>.FrameBase</H2>
<B>Base class of models with a fixed translation and orientation between frame_a and frame_b</B><p>
<IMG SRC="ModelicaAdditions.MultiBody.Interfaces.FrameBaseD.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.FrameBase">
<H3>Information</H3>
<PRE></PRE>
<p>
Fixed translation of frame_b with respect to frame_a, i.e.,
the frames of connectors frame_a and frame_b are parallel to each other.
The following parameters are defined:
</p>

<pre>
 r: Position vector from the origin of (connector) frame_a to the origin of
    (connector) frame_b, resolved in frame_a in [m].
</pre>
</p>
<PRE>
</PRE>
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>r[3]</TD><TD>{0,0,0}</TD><TD>Vector from frame_a to frame_b resolved in frame_a [m]</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
partial model FrameBase
  &quot;Base class of models with a fixed translation and orientation between frame_a and frame_b&quot;

  <I></I>
  extends <A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces.TwoTreeFrames"
>MultiBody.Interfaces.TwoTreeFrames</A>;
  parameter SIunits.Position r[3]={0,0,0}
    &quot;Vector from frame_a to frame_b resolved in frame_a&quot;;
protected
  SIunits.Velocity vaux[3];
  Real S_rel[3, 3]
    &quot;relative transformation matrix from frame_a to frame_b (defined in subclasses)&quot;
    ;
equation

    <I>/*general equations of a &quot;TreeJoint&quot; specialized to this class*/</I>
  Sb = Sa*transpose(S_rel);
  r0b = r0a + Sa*r;
  <I></I>
  vaux = cross(wa, r);
  vb = S_rel*(va + vaux);
  ab = S_rel*(aa + cross(za, r) + cross(wa, vaux));
  <I></I>
  wb = S_rel*wa;
  zb = S_rel*za;
  <I></I>
  <I>/* Transform the force and torque acting at frame_b to frame_a */</I>
  fa = transpose(S_rel)*fb;
  ta = transpose(S_rel)*tb + cross(r, fa);
end FrameBase;
</PRE>
<HR>
<H2><IMG SRC="ModelicaAdditions.MultiBody.Interfaces.BodyBaseI.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.BodyBase" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="ModelicaAdditions.MultiBody.Interfaces.BodyBase"></A><A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces"
>ModelicaAdditions.MultiBody.Interfaces</A>.BodyBase</H2>
<B>Inertia and mass properties of a rigid body</B><p>
<IMG SRC="ModelicaAdditions.MultiBody.Interfaces.BodyBaseD.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.BodyBase">
<H3>Information</H3>
<PRE></PRE>
<p>
This model should usually not be used directly, because the mass
properties have to be given as terminal variables and not as
parameters. This allows the computation of the mass properties
from other data, as well as the modification of the mass properties
at event points. The following variables have to be computed in
subclasses:
</p>

<pre>
  m     : Mass of body in [kg].
  rCM(3): Position vector from the origin of frame_a to the center
          of mass, resolved in frame_a in [m].
  I(3,3): Inertia tensor of the body with respect to the center of mass,
          resolved in frame_a in [kgm^2]. The matrix must be
          symmetric and positiv semi-definit.
</pre>
<PRE>
</PRE>
<H3>Modelica definition</H3>
<PRE>
model BodyBase &quot;Inertia and mass properties of a rigid body&quot;
  extends <A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces.OneFrame_a"
>MultiBody.Interfaces.OneFrame_a</A>;
  SIunits.Mass m;
  SIunits.Position rCM[3];
  SIunits.Inertia I[3, 3];
equation
  fa = m*(aa + cross(za, rCM) + cross(wa, cross(wa, rCM)));
  ta = I*za + cross(wa, I*wa) + cross(rCM, fa);
end BodyBase;
</PRE>
<HR>
<H2><IMG SRC="ModelicaAdditions.MultiBody.Interfaces.InteractI.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.Interact" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="ModelicaAdditions.MultiBody.Interfaces.Interact"></A><A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces"
>ModelicaAdditions.MultiBody.Interfaces</A>.Interact</H2>
<B>Superclass of joint, force and sensor elements</B><p>
<IMG SRC="ModelicaAdditions.MultiBody.Interfaces.InteractD.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.Interact">
<H3>Information</H3>
<PRE></PRE>
<p>
All relative kinematic quantities between frame_a and frame_b are
defined, i.e., relative position, relative velocity and
relative acceleration (resolved in frame_a).
</p>

<p>
For efficiency reasons, these calculations are performed in
subclasses (= the same equations are just solved for different
variables according to the usually needed causality).
The relative quantities, which are defined in this
model, have the following meaning:
</p>

<pre>
  S_rel : Rotation matrix relating frame_a and frame_b, i.e. if
          hb is vector h resoved in frame_b and ha is vector h resolved
          in frame_a, hb = S_rel*ha.
  r_rela: Vector from the origin of frame_a to the origin of frame_b,
          resolved in frame_a.
  v_rela: (Translational) velocity of frame_b with respect to frame_a,
          resolved in frame_a: v_rela = der(r_rela)
  w_rela: Angular velocity of frame_b with respect to frame_a,
          resolved in frame_a: w_rela = vec( der(S_rel)'*S_rel )
  a_rela: (Translational) acceleration of frame_b with respect to
          frame_a, resolved in frame_a: a_rela = der( v_rela )
  z_rela: Angular acceleration of frame_b with respect to frame_a,
          resolved in frame_a: z_rela = der( w_rela )
</pre>

<p>
If needed, all of the above quantities can also easily be resolved in
frame_b, according to  Xrelb = S_rel*Xrela . However note, that
v_relb is <b>not</b> der(r_relb)  (v_relb=S_rel*v_rela; r_relb=S_rel*r_rela).
</p>
<PRE>
</PRE>
<H3>Modelica definition</H3>
<PRE>
partial model Interact
  &quot;Superclass of joint, force and sensor elements&quot;
  Real S_rel[3, 3];
  SIunits.Position r_rela[3];
  SIunits.Velocity v_rela[3];
  SIunits.AngularVelocity w_rela[3];
  SIunits.Acceleration a_rela[3];
  SIunits.AngularAcceleration z_rela[3];
end Interact;
</PRE>
<HR>
<H2><IMG SRC="ModelicaAdditions.MultiBody.Interfaces.Interact2I.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.Interact2" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="ModelicaAdditions.MultiBody.Interfaces.Interact2"></A><A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces"
>ModelicaAdditions.MultiBody.Interfaces</A>.Interact2</H2>
<B>Superclass of CutJoint, Force and Sensor classes</B><p>
<IMG SRC="ModelicaAdditions.MultiBody.Interfaces.Interact2D.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.Interact2">
<H3>Modelica definition</H3>
<PRE>
partial model Interact2
  &quot;Superclass of CutJoint, Force and Sensor classes&quot;
  extends <A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces.TwoNoTreeFrames"
>MultiBody.Interfaces.TwoNoTreeFrames</A>;
  extends <A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces.Interact"
>MultiBody.Interfaces.Interact</A>;
  SIunits.Velocity vaux[3];
equation
  S_rel = transpose(Sb)*Sa;
  <I></I>
  <I>/*relative position vectors*/</I>
  r_rela = transpose(Sa)*(r0b - r0a);
  <I></I>
  <I>/*relative velocities*/</I>
  vaux = cross(wa, r_rela);
  v_rela = transpose(S_rel)*vb - va - vaux;
  w_rela = transpose(S_rel)*wb - wa;
  <I></I>
  <I>/*relative accelerations*/</I>
  a_rela = transpose(S_rel)*ab - aa - cross(za, r_rela) - cross(wa, vaux + 2*
    v_rela);
  z_rela = transpose(S_rel)*zb - za - cross(wa, w_rela);
end Interact2;
</PRE>
<HR>
<H2><IMG SRC="ModelicaAdditions.MultiBody.Interfaces.ForceI.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.Force" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="ModelicaAdditions.MultiBody.Interfaces.Force"></A><A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces"
>ModelicaAdditions.MultiBody.Interfaces</A>.Force</H2>
<B>Superclass of (general) force elements</B><p>
<IMG SRC="ModelicaAdditions.MultiBody.Interfaces.ForceD.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.Force">
<H3>Information</H3>
<PRE></PRE>
<p>
A force element exerts a force and torque on frame_a and
with opposite direction on frame_b. In subclasses of this
class the cut-forces/torques at frame_a, have to be given
as function of the relative quantities computed in class
Interact2 (S_rel, r_rela, v_rela, w_rela).
</p>

<p>
In class Force, the cut-forces/torques at frame_b are computed
from the cut-forces/torques at frame_a.
</p>

<p><b>Note</b>:<br>
Both frames of a force element have <b>always</b> to be connected
at frame_a of a joint, of a body or of the inertial system.
It is not possible to, e.g., connect two force elements in series.
</p>
<HTML>
<PRE></PRE>
<H3>Modelica definition</H3>
<PRE>
model Force &quot;Superclass of (general) force elements&quot;
  extends <A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces.Interact2"
>MultiBody.Interfaces.Interact2</A>;
equation
  fb = S_rel*fa;
  tb = S_rel*ta - S_rel*cross(r_rela, fa);
end Force;
</PRE>
<HR>
<H2><IMG SRC="ModelicaAdditions.MultiBody.Interfaces.TreeJointI.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.TreeJoint" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="ModelicaAdditions.MultiBody.Interfaces.TreeJoint"></A><A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces"
>ModelicaAdditions.MultiBody.Interfaces</A>.TreeJoint</H2>
<B>Superclass of joints used in the spanning tree</B><p>
<IMG SRC="ModelicaAdditions.MultiBody.Interfaces.TreeJointD.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.TreeJoint">
<H3>Information</H3>
<PRE></PRE>
<p>
A joint has two mechanical cuts which may move relative to each other. In
every cut a coordinate system is rigidly attached, called frame_a and frame_b,
correspondingly. It is a massless element in which no energy is stored.
Mathematically, a joint transforms the kinematic properties of frame_a to
frame_b and at the same time transforms the force and torque acting on
frame_b to frame_a.
</p>

<p>
A general multibody system with closed kinematic loops is handeled by dividing
the joints into two distinct sets: <b>Tree-Joints</b> and <b>Cut-Joints</b>.
After removal of all of the Cut-Joints, the resulting system must have a
tree-structure. Class TreeJoint is used as a superclass for Tree-Joints.
</p>

<p>
The relative motion between the two cut-frames of a Tree-Joint is described
by f (0 <= f <= 6) generalized minimal-coordinates q and their first and
second derivatives qd, qdd. In subclasses of class TreeJoint the relative
kinematic quantities are given as functions of q, qd, qdd, according to the
specific joint type. In class TreeJoint the relationships are provided
between the kinematic and dynamic quantities of frame_a and frame_b and of the
relative quantities.
</p>

<p>
In order to speedup the generation of the equations, the common equations of
TreeJoint classes are <b>not</b> stored in model TreeJoint, but in the
specific submodel. This has the advantage that special joint properties
(like S_rel=identity(3), i.e., the relative transformation matrix is a
unit matrix) are already utilized and the Modelica translator does not have
to waste time and space to find this out by symbolic formula transformation.
The common equations which could be stored in the TreeJoint
model are given as a comment below.
</p>
<PRE></PRE>
<H3>Modelica definition</H3>
<PRE>
partial model TreeJoint
  &quot;Superclass of joints used in the spanning tree&quot;
  extends <A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces.TwoTreeFrames"
>MultiBody.Interfaces.TwoTreeFrames</A>;
  extends <A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces.Interact"
>MultiBody.Interfaces.Interact</A>;
equation
  <I>/* Equations to relate quantities of frame_a and frame_b.
     These equations are defined in the submodels and are
     adapted to the particular joint.

    Sb = Sa*transpose(S_rel);
    r0b = r0a + Sa*r_rela;

    vaux = cross(wa,r_rela)
    vb   = S_rel*(va + v_rela + vaux)
    wb   = S_rel*(wa + w_rela)

    ab   = S_rel*( aa + a_rela + cross(za,r_rela) + cross(wa,vaux+2*v_rela) )
    zb   = S_rel*( za + z_rela + cross(wa,w_rela) )

    ab = S_rel*aa;
    zb = S_rel*(za + z_rela + cross(wa, w_rela));

    fa = transpose(S_rel)*fb;
    ta = transpose(S_rel)*tb + cross(r_rela,fa);
*/</I>
end TreeJoint;
</PRE>
<HR>
<H2><IMG SRC="ModelicaAdditions.MultiBody.Interfaces.planarRotationI.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.planarRotation" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="ModelicaAdditions.MultiBody.Interfaces.planarRotation"></A><A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces"
>ModelicaAdditions.MultiBody.Interfaces</A>.planarRotation</H2>
<B>Determine transformation matrix for planar rotation</B><p>
<IMG SRC="ModelicaAdditions.MultiBody.Interfaces.planarRotationD.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.planarRotation">
<H3>Modelica definition</H3>
<PRE>
function planarRotation
  &quot;Determine transformation matrix for planar rotation&quot;
  input Real n[3] &quot;normalized axis of rotation&quot;;
  input Modelica.SIunits.Angle angle &quot;rotation angle&quot;;
  output Real S[3, 3]
    &quot;transformation matrix to rotate a frame_along axis n around angle&quot;
    ;
algorithm
  S := [n]*transpose([n]) + (identity(3) - [n]*transpose([n]))*cos(angle) -
    skew(n)*sin(angle);
end planarRotation;
</PRE>
<HR>
<H2><IMG SRC="ModelicaAdditions.MultiBody.Interfaces.axisRotationI.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.axisRotation" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="ModelicaAdditions.MultiBody.Interfaces.axisRotation"></A><A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces"
>ModelicaAdditions.MultiBody.Interfaces</A>.axisRotation</H2>
<B>Determine transformation matrix for rotation around one axis</B><p>
<IMG SRC="ModelicaAdditions.MultiBody.Interfaces.axisRotationD.gif" ALT="ModelicaAdditions.MultiBody.Interfaces.axisRotation">
<H3>Modelica definition</H3>
<PRE>
function axisRotation
  &quot;Determine transformation matrix for rotation around one axis&quot;
  input Integer i(min=1, max=3) &quot;rotate around axis i&quot;;
  input Modelica.SIunits.Angle angle &quot;rotation angle&quot;;
  output Real S[3, 3]
    &quot;transformation matrix to rotate a frame along axis i around angle&quot;
    ;
algorithm
  S := if i == 1 then [1, 0, 0; 0, Modelica.Math.cos(angle), Modelica.Math.sin
    (angle); 0, -Modelica.Math.sin(angle), Modelica.Math.cos(angle)] else if i
     == 2 then [Modelica.Math.cos(angle), 0, -Modelica.Math.sin(angle); 0, 1, 0
    ; Modelica.Math.sin(angle), 0, Modelica.Math.cos(angle)] else [
    Modelica.Math.cos(angle), Modelica.Math.sin(angle), 0; -Modelica.Math.sin(
    angle), Modelica.Math.cos(angle), 0; 0, 0, 1];
  <I></I>
end axisRotation;
</PRE>
<HR>
<address>HTML-documentation generated by <a href="http://www.dynasim.se/">Dymola</a> Tue Jun 20 22:16:47 2000
.
</address></BODY>
</HTML>
