<HTML>
<HEAD><META name="HTML-Generator" content="Dymola"><TITLE>ModelicaAdditions</TITLE></HEAD>
<BODY><P>
<H2><A NAME="ModelicaAdditions.MultiBody.Sensors"></A><A HREF="ModelicaAdditions_MultiBody.html#ModelicaAdditions.MultiBody"
>ModelicaAdditions.MultiBody</A>.Sensors</H2>
<B>Sensors for 3D mechanical components</B>
<P>
<A HREF="ModelicaAdditions_MultiBody_Sensors.html#ModelicaAdditions.MultiBody.Sensors.Sensor"
><IMG SRC="ModelicaAdditions.MultiBody.Sensors.SensorI.gif" ALT="ModelicaAdditions.MultiBody.Sensors.Sensor" WIDTH=80  HEIGHT=80 ></A>
<A HREF="ModelicaAdditions_MultiBody_Sensors.html#ModelicaAdditions.MultiBody.Sensors.LineSensor"
><IMG SRC="ModelicaAdditions.MultiBody.Sensors.LineSensorI.gif" ALT="ModelicaAdditions.MultiBody.Sensors.LineSensor" WIDTH=80  HEIGHT=80 ></A>
<P><P>
<H3>Information</H3>
<PRE>
</PRE>
<p>
This package contains sensor elements
</p>

<dl>
<dt><b>Main Author:</b>
<dd><a href="http://www.op.dlr.de/~otter/">Martin Otter</a><br>
    Deutsches Zentrum f&uuml;r Luft und Raumfahrt e.V. (DLR)<br>
    Institut f&uuml;r Robotik und Mechatronik<br>
    Postfach 1116<br>
    D-82230 Wessling<br>
    Germany<br>
    email: <A HREF="mailto:Martin.Otter@dlr.de">Martin.Otter@dlr.de</A><br>
</dl>
<br>

<p><b>Release Notes:</b></p>
<ul>
<li><i>April 5, 2000</i>
       by <a href="http://www.op.dlr.de/~otter/">Martin Otter</a>:<br>
       Realized.</li>
</ul>
<br>

<p><b>Copyright (C) 2000, DLR.</b></p>

<p><i>
The Modelica package is <b>free</b> software; it can be redistributed and/or modified
under the terms of the <b>Modelica license</b>, see the license conditions
and the accompanying <b>disclaimer</b> in the documentation of package
Modelica in file "Modelica/package.mo".
</i></p>
<PRE>
</PRE><P>
<HR>
<H2><IMG SRC="ModelicaAdditions.MultiBody.Sensors.SensorI.gif" ALT="ModelicaAdditions.MultiBody.Sensors.Sensor" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="ModelicaAdditions.MultiBody.Sensors.Sensor"></A><A HREF="ModelicaAdditions_MultiBody_Sensors.html#ModelicaAdditions.MultiBody.Sensors"
>ModelicaAdditions.MultiBody.Sensors</A>.Sensor</H2>
<B>General sensor element</B><p>
<IMG SRC="ModelicaAdditions.MultiBody.Sensors.SensorD.gif" ALT="ModelicaAdditions.MultiBody.Sensors.Sensor">
<H3>Information</H3>
<PRE>
A sensor element determines the relative kinematic quantities
between frame_a and frame_b (= variables of superclass
Interact). It does not exert forces or torques.
The following relative variables can be determined:

  S_rel : Rotation matrix relating frame_a and frame_b, i.e. if
         hb is vector h resoved in frame_b and ha is vector h resolved
         in frame_a, hb = S_rel*ha.
  r_rela: Vector from the origin of frame_a to the origin of frame_b,
         resolved in frame_a.
  v_rela: (Translational) velocity of frame_b with respect to frame_a,
         resolved in frame_a: v_rela = der(r_rela)
  w_rela: Angular velocity of frame_b with respect to frame_a,
         resolved in frame_a: v_rela = vec( der(S_rel)'*S_rel )
  a_rela: (Translational) acceleration of frame_b with respect to
         frame_a, resolved in frame_a: a_rela = der( v_rela )
  z_rela: Angular acceleration of frame_b with respect to frame_a,
         resolved in frame_a: z_rela = der( w_rela )

If needed, all of the above quantities can also easily be resolved in
frame_b, according to  Xrelb = S_rel*Xrela . However note, that
 v_relb  is NOT  der(r_relb)  (v_relb=S_rel*v_rela; r_relb=S_rel*r_rela).
</PRE>
<H3>Modelica definition</H3>
<PRE>
model Sensor &quot;General sensor element&quot;
  extends <A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces.Interact2"
>MultiBody.Interfaces.Interact2</A>;
equation
  fa = zeros(3);
  fb = zeros(3);
  ta = zeros(3);
  tb = zeros(3);
end Sensor;
</PRE>
<HR>
<H2><IMG SRC="ModelicaAdditions.MultiBody.Sensors.LineSensorI.gif" ALT="ModelicaAdditions.MultiBody.Sensors.LineSensor" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="ModelicaAdditions.MultiBody.Sensors.LineSensor"></A><A HREF="ModelicaAdditions_MultiBody_Sensors.html#ModelicaAdditions.MultiBody.Sensors"
>ModelicaAdditions.MultiBody.Sensors</A>.LineSensor</H2>
<B>Measures kinematic data along a line</B><p>
<IMG SRC="ModelicaAdditions.MultiBody.Sensors.LineSensorD.gif" ALT="ModelicaAdditions.MultiBody.Sensors.LineSensor">
<H3>Information</H3>
<PRE>
The distance as well as the first and second derivative of the
distance between the cut-frames A and B are determined.

Terminal variables:
  s    : The distance between the origin of frame_a and the
         origin of frame_b in [m].
  sd   : The first derivative of s in [m/s].
  sdd  : The second derivative of s in [m/s^2].
  na(3): Unit vector on the line from the origin of frame_a to
         the origin of frame_b, resolved in frame_a.

Parameters:
  sEps: When  sd  and  sdd  are calculated, a division by zero takes
        place, if the distance becomes zero. Therefore, for this
        calculation the modified distance  smod = max(s, sEps)  is used.
</PRE>
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>sEps</TD><TD>1.E-6</TD><TD>prevent zero-division if rel. distance s=0 [m]</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
model LineSensor &quot;Measures kinematic data along a line&quot;
  extends <A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces.Interact2"
>MultiBody.Interfaces.Interact2</A>;
  parameter Real sEps=1.E-6
    &quot;prevent zero-division if rel. distance s=0 [m]&quot;;
  SIunits.Acceleration sdd;
  Real na[3];
  SIunits.Position smod;
  <I></I>
  SIunits.Position s;
  SIunits.Velocity sd;
  <A HREF="../../modelica/help/Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.OutPort"
>Modelica.Blocks.Interfaces.OutPort</A> outPort_s(final n=1);
  <A HREF="../../modelica/help/Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.OutPort"
>Modelica.Blocks.Interfaces.OutPort</A> outPort_sd(final n=1);
equation
  <I></I>
  fa = zeros(3);
  fb = zeros(3);
  ta = zeros(3);
  tb = zeros(3);
  <I></I>
  s = outPort_s.signal[1];
  sd = outPort_sd.signal[1];
  <I></I>
  <I>/*calculate variables along line*/</I>
  s = sqrt(r_rela*r_rela);
  <I></I>
  smod = max([s, sEps]);
  na = r_rela/smod;
  sd = na*v_rela;
  sdd = na*a_rela + (v_rela*v_rela - sd*sd)/smod;
end LineSensor;
</PRE>
<HR>
<address>HTML-documentation generated by <a href="http://www.dynasim.se/">Dymola</a> Tue Jun 20 22:18:46 2000
.
</address></BODY>
</HTML>
