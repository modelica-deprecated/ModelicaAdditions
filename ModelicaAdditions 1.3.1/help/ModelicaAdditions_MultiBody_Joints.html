<HTML>
<HEAD><META name="HTML-Generator" content="Dymola"><TITLE>ModelicaAdditions</TITLE></HEAD>
<BODY><P>
<H2><A NAME="ModelicaAdditions.MultiBody.Joints"></A><A HREF="ModelicaAdditions_MultiBody.html#ModelicaAdditions.MultiBody"
>ModelicaAdditions.MultiBody</A>.Joints</H2>
<B>Joints in the spanning tree</B>
<P>
<A HREF="ModelicaAdditions_MultiBody_Joints.html#ModelicaAdditions.MultiBody.Joints.Revolute"
><IMG SRC="ModelicaAdditions.MultiBody.Joints.RevoluteI.gif" ALT="ModelicaAdditions.MultiBody.Joints.Revolute" WIDTH=80  HEIGHT=80 ></A>
<A HREF="ModelicaAdditions_MultiBody_Joints.html#ModelicaAdditions.MultiBody.Joints.Prismatic"
><IMG SRC="ModelicaAdditions.MultiBody.Joints.PrismaticI.gif" ALT="ModelicaAdditions.MultiBody.Joints.Prismatic" WIDTH=80  HEIGHT=80 ></A>
<A HREF="ModelicaAdditions_MultiBody_Joints.html#ModelicaAdditions.MultiBody.Joints.Screw"
><IMG SRC="ModelicaAdditions.MultiBody.Joints.ScrewI.gif" ALT="ModelicaAdditions.MultiBody.Joints.Screw" WIDTH=80  HEIGHT=80 ></A>
<A HREF="ModelicaAdditions_MultiBody_Joints.html#ModelicaAdditions.MultiBody.Joints.Cylindrical"
><IMG SRC="ModelicaAdditions.MultiBody.Joints.CylindricalI.gif" ALT="ModelicaAdditions.MultiBody.Joints.Cylindrical" WIDTH=80  HEIGHT=80 ></A>
<A HREF="ModelicaAdditions_MultiBody_Joints.html#ModelicaAdditions.MultiBody.Joints.Universal"
><IMG SRC="ModelicaAdditions.MultiBody.Joints.UniversalI.gif" ALT="ModelicaAdditions.MultiBody.Joints.Universal" WIDTH=80  HEIGHT=80 ></A>
<A HREF="ModelicaAdditions_MultiBody_Joints.html#ModelicaAdditions.MultiBody.Joints.Planar"
><IMG SRC="ModelicaAdditions.MultiBody.Joints.PlanarI.gif" ALT="ModelicaAdditions.MultiBody.Joints.Planar" WIDTH=80  HEIGHT=80 ></A>
<A HREF="ModelicaAdditions_MultiBody_Joints.html#ModelicaAdditions.MultiBody.Joints.Spherical"
><IMG SRC="ModelicaAdditions.MultiBody.Joints.SphericalI.gif" ALT="ModelicaAdditions.MultiBody.Joints.Spherical" WIDTH=80  HEIGHT=80 ></A>
<A HREF="ModelicaAdditions_MultiBody_Joints.html#ModelicaAdditions.MultiBody.Joints.FreeMotion"
><IMG SRC="ModelicaAdditions.MultiBody.Joints.FreeMotionI.gif" ALT="ModelicaAdditions.MultiBody.Joints.FreeMotion" WIDTH=80  HEIGHT=80 ></A>
<P><P>
<H3>Information</H3>
<PRE>
</PRE>
<p>
This package contains elements to model ideal joints.
</p>

<dl>
<dt><b>Main Author:</b>
<dd><a href="http://www.op.dlr.de/~otter/">Martin Otter</a><br>
    Deutsches Zentrum f&uuml;r Luft und Raumfahrt e.V. (DLR)<br>
    Institut f&uuml;r Robotik und Mechatronik<br>
    Postfach 1116<br>
    D-82230 Wessling<br>
    Germany<br>
    email: <A HREF="mailto:Martin.Otter@dlr.de">Martin.Otter@dlr.de</A><br>
</dl>
<br>

<p><b>Release Notes:</b></p>
<ul>
<li><i>April 5, 2000</i>
       by <a href="http://www.op.dlr.de/~otter/">Martin Otter</a>:<br>
       Realized.</li>
</ul>
<br>

<p><b>Copyright (C) 2000, DLR.</b></p>

<p><i>
The Modelica package is <b>free</b> software; it can be redistributed and/or modified
under the terms of the <b>Modelica license</b>, see the license conditions
and the accompanying <b>disclaimer</b> in the documentation of package
Modelica in file "Modelica/package.mo".
</i></p>
<PRE>
</PRE><P>
<HR>
<H2><IMG SRC="ModelicaAdditions.MultiBody.Joints.RevoluteI.gif" ALT="ModelicaAdditions.MultiBody.Joints.Revolute" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="ModelicaAdditions.MultiBody.Joints.Revolute"></A><A HREF="ModelicaAdditions_MultiBody_Joints.html#ModelicaAdditions.MultiBody.Joints"
>ModelicaAdditions.MultiBody.Joints</A>.Revolute</H2>
<B>Revolute joint (1 degree-of-freedom, used in spanning tree)</B><p>
<IMG SRC="ModelicaAdditions.MultiBody.Joints.RevoluteD.gif" ALT="ModelicaAdditions.MultiBody.Joints.Revolute">
<H3>Information</H3>
<PRE></PRE>
<p>
Joint where frame_b rotates around axis n which is fixed in frame_a.
The joint axis has an additional flange where it can be
driven with elements of the Modelica.Mechanics.Rotational library.
The relative angle q [rad] and the relative angular velocity
qd [rad/s] are used as state variables.
</p>

<p>
The following parameters are used to define the joint:
</p>
<pre>
  n : Axis of rotation resolved in frame_a (= same as in frame_b).
      n  must not necessarily be a unit vector. E.g.,
         n = {0, 0, 1} or n = {1, 0, 1}
  q0: Rotation angle offset in [deg].
      If q=q0, frame_a and frame_b are identical.
  startValueFixed: true, if start values of q, qd are fixed.
</pre>
<PRE>
</PRE>
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>n[3]</TD><TD>{0,0,1}</TD><TD>Axis of rotation resolved in frame_a (= same as in frame_b)</TD></TR>
<TR><TD>q0</TD><TD>0</TD><TD>Rotation angle offset (see info) [deg]</TD></TR>
<TR><TD>startValueFixed</TD><TD>false</TD><TD>true, if start values of q, qd are fixed</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
model Revolute
  &quot;Revolute joint (1 degree-of-freedom, used in spanning tree)&quot;
  <I></I>
  extends <A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces.TreeJoint"
>MultiBody.Interfaces.TreeJoint</A>;
  parameter Real n[3]={0,0,1}
    &quot;Axis of rotation resolved in frame_a (= same as in frame_b)&quot;;
  parameter Real q0=0 &quot;Rotation angle offset (see info) [deg]&quot;;
  parameter Boolean startValueFixed=false
    &quot;true, if start values of q, qd are fixed&quot;;
  SIunits.Angle q(final fixed=startValueFixed);
  SIunits.AngularVelocity qd(final fixed=startValueFixed);
  SIunits.AngularAcceleration qdd;
  SIunits.Angle qq;
  Real nn[3];
  Real sinq;
  Real cosq;
  <I></I>
  <A HREF="../../modelica/help/Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_a"
>Modelica.Mechanics.Rotational.Interfaces.Flange_a</A> axis;
  <A HREF="../../modelica/help/Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_b"
>Modelica.Mechanics.Rotational.Interfaces.Flange_b</A> bearing;
equation
  axis.phi = q;
  bearing.phi = 0;
  <I></I>
  <I>// define states</I>
  qd = der(q);
  qdd = der(qd);
  <I></I>
  <I>/*rotation matrix*/</I>
  nn = n/sqrt(n*n);
  qq = q - q0*PI/180;
  sinq = sin(qq);
  cosq = cos(qq);
  S_rel = [nn]*transpose([nn]) + (identity(3) - [nn]*transpose([nn]))*cosq -
    skew(nn)*sinq;
  <I></I>
  <I>/*other kinematic quantities*/</I>
  r_rela = zeros(3);
  v_rela = zeros(3);
  a_rela = zeros(3);
  w_rela = nn*qd;
  z_rela = nn*qdd;
  <I></I>
  <I>/* Transform the kinematic quantities from frame_a to frame_b and the
     force and torque acting at frame_b to frame_a
     (= general equations of a &quot;TreeJoint&quot; specialized to this class).
  */</I>
  Sb = Sa*transpose(S_rel);
  r0b = r0a;
  <I></I>
  vb = S_rel*va;
  wb = S_rel*(wa + w_rela);
  <I></I>
  ab = S_rel*aa;
  zb = S_rel*(za + z_rela + cross(wa, w_rela));
  <I></I>
  fa = transpose(S_rel)*fb;
  ta = transpose(S_rel)*tb;
  <I></I>
  <I>// d'Alemberts principle</I>
  axis.tau = nn*tb;
end Revolute;
</PRE>
<HR>
<H2><IMG SRC="ModelicaAdditions.MultiBody.Joints.PrismaticI.gif" ALT="ModelicaAdditions.MultiBody.Joints.Prismatic" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="ModelicaAdditions.MultiBody.Joints.Prismatic"></A><A HREF="ModelicaAdditions_MultiBody_Joints.html#ModelicaAdditions.MultiBody.Joints"
>ModelicaAdditions.MultiBody.Joints</A>.Prismatic</H2>
<B>Prismatic joint (1 degree-of-freedom, used in spanning tree)</B><p>
<IMG SRC="ModelicaAdditions.MultiBody.Joints.PrismaticD.gif" ALT="ModelicaAdditions.MultiBody.Joints.Prismatic">
<H3>Information</H3>
<PRE></PRE>
<p>
Joint where frame_b is translated around axis n which is fixed in frame_a.
The joint axis has an additional flange where it can be
driven with elements of the Modelica.Mechanics.Translational library.
The relative distance q [m] and the relative velocity qd [m] are
used as state variables.
</p>

<p>
The following parameters are used to define the joint:
</p>
<pre>
  n : Axis of translation resolved in frame_a (= same as in frame_b).
      n must not necessarily be a unit vector. E.g.,
         n = {0, 0, 1} or n = {1, 0, 1}
  q0: Relative distance offset in [m].
      (in the direction of n).
      If q=q0, frame_a and frame_b are identical.
  startValueFixed: true, if start values of q, qd are fixed.
</pre>
<PRE>
</PRE>
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>n[3]</TD><TD>{1,0,0}</TD><TD>Axis of translation resolved in frame_a (= same as in frame_b)</TD></TR>
<TR><TD>q0</TD><TD>0</TD><TD>Relative distance offset(see info) [m]</TD></TR>
<TR><TD>startValueFixed</TD><TD>false</TD><TD>true, if start values of q, qd are fixed</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
model Prismatic
  &quot;Prismatic joint (1 degree-of-freedom, used in spanning tree)&quot;
  extends <A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces.TreeJoint"
>MultiBody.Interfaces.TreeJoint</A>;
  parameter Real n[3]={1,0,0}
    &quot;Axis of translation resolved in frame_a (= same as in frame_b)&quot;;
  parameter SIunits.Position q0=0
    &quot;Relative distance offset(see info)&quot;;
  parameter Boolean startValueFixed=false
    &quot;true, if start values of q, qd are fixed&quot;;
  SIunits.Position q(final fixed=startValueFixed);
  SIunits.Velocity qd(final fixed=startValueFixed);
  SIunits.Acceleration qdd;
  SIunits.Position qq;
  Real nn[3];
  SIunits.Velocity vaux[3];
  <I></I>
  <A HREF="../../modelica/help/Modelica_Mechanics_Translational_Interfaces.html#Modelica.Mechanics.Translational.Interfaces.Flange_a"
>Modelica.Mechanics.Translational.Interfaces.Flange_a</A> axis;
  <A HREF="../../modelica/help/Modelica_Mechanics_Translational_Interfaces.html#Modelica.Mechanics.Translational.Interfaces.Flange_b"
>Modelica.Mechanics.Translational.Interfaces.Flange_b</A> bearing;
equation
  axis.s = q;
  bearing.s = 0;
  <I></I>
  <I>// define states</I>
  qd = der(q);
  qdd = der(qd);
  <I></I>
  <I>/*normalize axis vector*/</I>
  nn = n/sqrt(n*n);
  <I></I>
  <I>/*kinematic quantities*/</I>
  S_rel = identity(3);
  qq = q - q0;
  r_rela = nn*qq;
  v_rela = nn*qd;
  a_rela = nn*qdd;
  w_rela = zeros(3);
  z_rela = zeros(3);
  <I></I>
  <I>/* Transform the kinematic quantities from frame_a to frame_b and the
     force and torque acting at frame_b to frame_a
     (= general equations of a &quot;TreeJoint&quot; specialized to this class).
  */</I>
  Sb = Sa;
  r0b = r0a + Sa*r_rela;
  <I></I>
  vaux = cross(wa, r_rela);
  vb = va + v_rela + vaux;
  wb = wa;
  <I></I>
  ab = aa + a_rela + cross(za, r_rela) + cross(wa, vaux + 2*v_rela);
  zb = za;
  <I></I>
  fa = fb;
  ta = tb + cross(r_rela, fa);
  <I></I>
  <I>// d'Alemberts principle</I>
  axis.f = nn*fb;
end Prismatic;
</PRE>
<HR>
<H2><IMG SRC="ModelicaAdditions.MultiBody.Joints.ScrewI.gif" ALT="ModelicaAdditions.MultiBody.Joints.Screw" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="ModelicaAdditions.MultiBody.Joints.Screw"></A><A HREF="ModelicaAdditions_MultiBody_Joints.html#ModelicaAdditions.MultiBody.Joints"
>ModelicaAdditions.MultiBody.Joints</A>.Screw</H2>
<B>Screw joint (1 degree-of-freedom, used in spanning tree)</B><p>
<IMG SRC="ModelicaAdditions.MultiBody.Joints.ScrewD.gif" ALT="ModelicaAdditions.MultiBody.Joints.Screw">
<H3>Information</H3>
<PRE></PRE>
<p>
Joint where frame_b rotates around axis n which is fixed in frame_a
and at the same time is translated around the same axis. The rotational
and translational movement are coupled by a fixed factor.
The joint axis has an additional flange where it can be
driven with elements of the Modelica.Mechanics.Rotational library.
The relative angle q [rad] and the relative angular velocity
qd [rad/s] are used as state variables.
</p>

<p>
The following parameters are used to define the joint:
</p>
<pre>
  n    : Axis of rotation resolved in frame_a (= same as in frame_b).
         n  must not necessarily be a unit vector. E.g.,
            n = {0, 0, 1} or n = {1, 0, 1}
  q0   : Rotation angle offset in [deg].
         If q=q0, frame_a and frame_b are identical.
  R    : Radius of the screw in [m].
  slope: Slope of the screw in [deg].
         (relative distance = (q-q0)*R*tan( slope*PI/180 ))
  startValueFixed: true, if start values of q, qd are fixed.
</pre>
<PRE>
</PRE>
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>n[3]</TD><TD>{1,0,0}</TD><TD>Screw axis resolved in frame_a and frame_b</TD></TR>
<TR><TD>R</TD><TD>0.01</TD><TD>Screw radius [m]</TD></TR>
<TR><TD>slope</TD><TD>1</TD><TD>Screw slope in [deg] (slope&gt;0)</TD></TR>
<TR><TD>q0</TD><TD>0</TD><TD>Screw axis angle offset in [deg]</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
model Screw
  &quot;Screw joint (1 degree-of-freedom, used in spanning tree)&quot;
  extends <A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces.TreeJoint"
>MultiBody.Interfaces.TreeJoint</A>;
  parameter Real n[3]={1,0,0}
    &quot;Screw axis resolved in frame_a and frame_b&quot;;
  parameter SIunits.Length R=0.01 &quot;Screw radius&quot;;
  parameter Real slope=1 &quot;Screw slope in [deg] (slope&gt;0)&quot;;
  parameter Real q0=0 &quot;Screw axis angle offset in [deg]&quot;;
  SIunits.Angle q(start=0, fixed=true);
  SIunits.AngularVelocity qd(start=0, fixed=true);
  SIunits.AngularAcceleration qdd;
  Real nn[3];
  Real nt[3];
  Real sinq;
  Real cosq;
  Real ri;
  Real vaux[3];
  Real qq;
  <I></I>
  <A HREF="../../modelica/help/Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_a"
>Modelica.Mechanics.Rotational.Interfaces.Flange_a</A> axis;
  <A HREF="../../modelica/help/Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_b"
>Modelica.Mechanics.Rotational.Interfaces.Flange_b</A> bearing;
equation
  axis.phi = q;
  bearing.phi = 0;
  <I></I>
  <I>// define states</I>
  qd = der(q);
  qdd = der(qd);
  <I></I>
  <I>/*rotation matrix*/</I>
  nn = n/sqrt(n*n);
  qq = q - q0*PI/180;
  sinq = sin(qq);
  cosq = cos(qq);
  S_rel = [nn]*transpose([nn]) + (identity(3) - [nn]*transpose([nn]))*cosq -
    skew(nn)*sinq;
  <I></I>
  <I>/*other kinematic quantities*/</I>
  ri = R*tan(slope*PI/180);
  nt = nn*ri;
  r_rela = nt*qq;
  v_rela = nt*qd;
  a_rela = nt*qdd;
  <I></I>
  w_rela = nn*qd;
  z_rela = nn*qdd;
  <I></I>
  <I>/*Transform the kinematic quantities from frame_a to frame_b and the
 force and torque acting at frame_b to frame_a
 (= general equations of a &quot;TreeJoint&quot; specialized to this class).
*/</I>
  Sb = Sa*transpose(S_rel);
  r0b = r0a + Sa*r_rela;
  <I></I>
  vaux = cross(wa, r_rela);
  vb = S_rel*(va + v_rela + vaux);
  wb = S_rel*(wa + w_rela);
  <I></I>
  ab = S_rel*(aa + a_rela + cross(za, r_rela) + cross(wa, vaux + 2*v_rela));
  zb = S_rel*(za + z_rela + cross(wa, w_rela));
  <I></I>
  fa = transpose(S_rel)*fb;
  ta = transpose(S_rel)*tb + cross(r_rela, fa);
  <I></I>
  <I>// d'Alemberts principle</I>
  axis.tau = nn*tb + nt*fb;
end Screw;
</PRE>
<HR>
<H2><IMG SRC="ModelicaAdditions.MultiBody.Joints.CylindricalI.gif" ALT="ModelicaAdditions.MultiBody.Joints.Cylindrical" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="ModelicaAdditions.MultiBody.Joints.Cylindrical"></A><A HREF="ModelicaAdditions_MultiBody_Joints.html#ModelicaAdditions.MultiBody.Joints"
>ModelicaAdditions.MultiBody.Joints</A>.Cylindrical</H2>
<B>Cylindrical joint (2 degrees-of-freedom, used in spanning tree)</B><p>
<IMG SRC="ModelicaAdditions.MultiBody.Joints.CylindricalD.gif" ALT="ModelicaAdditions.MultiBody.Joints.Cylindrical">
<H3>Information</H3>
<PRE></PRE>
<p>
Joint where frame_b rotates around axis n which is fixed in frame_a
and translates independently around the same axis.
The relative angle revolute.q [rad], the relative distance
prismatic.q [m], the relative angular velocity revolute.qd [rad/s]
and the relative velocity prismatic.qd [m/s] are used as state variables.
</p>

<p>
The following parameters are used to define the joint:
</p>
  n    : Axis of cylindrical joint resolved in frame_a (= same as in frame_b).
         n  must not necessarily be a unit vector.
  qt0  : If revolute.q=qr0 and prismatic.q=qt0,
  qr0    frame_a and frame_b are identical.
  startValueFixed: true, if start values of q, qd are fixed.
</pre>
<PRE>
</PRE>
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>n[3]</TD><TD>{1,0,0}</TD><TD>Cylinder axis resolved in frame_a (= same as in frame_b)</TD></TR>
<TR><TD>qt0</TD><TD>0</TD><TD>Distance offset (see info) [m]</TD></TR>
<TR><TD>qr0</TD><TD>0</TD><TD>Rotation angle offset (see info) in [deg]</TD></TR>
<TR><TD>startValueFixed</TD><TD>false</TD><TD>true, if start values of q, qd are fixed</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
model Cylindrical
  &quot;Cylindrical joint (2 degrees-of-freedom, used in spanning tree)&quot;
  extends <A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces.TwoTreeFrames"
>MultiBody.Interfaces.TwoTreeFrames</A>;
  parameter Real n[3]={1,0,0}
    &quot;Cylinder axis resolved in frame_a (= same as in frame_b)&quot;;
  parameter SIunits.Position qt0=0 &quot;Distance offset (see info)&quot;;
  parameter Real qr0=0 &quot;Rotation angle offset (see info) in [deg]&quot;;
  parameter Boolean startValueFixed=false
    &quot;true, if start values of q, qd are fixed&quot;;
  <A HREF="ModelicaAdditions_MultiBody_Joints.html#ModelicaAdditions.MultiBody.Joints.Prismatic"
>MultiBody.Joints.Prismatic</A> prismatic(
    n=n,
    q0=qt0,
    startValueFixed=startValueFixed);
  <A HREF="ModelicaAdditions_MultiBody_Joints.html#ModelicaAdditions.MultiBody.Joints.Revolute"
>MultiBody.Joints.Revolute</A> revolute(
    n=n,
    q0=qr0,
    startValueFixed=startValueFixed);
equation
  connect(frame_a, prismatic.frame_a);
  connect(prismatic.frame_b, revolute.frame_a);
  connect(revolute.frame_b, frame_b);
end Cylindrical;
</PRE>
<HR>
<H2><IMG SRC="ModelicaAdditions.MultiBody.Joints.UniversalI.gif" ALT="ModelicaAdditions.MultiBody.Joints.Universal" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="ModelicaAdditions.MultiBody.Joints.Universal"></A><A HREF="ModelicaAdditions_MultiBody_Joints.html#ModelicaAdditions.MultiBody.Joints"
>ModelicaAdditions.MultiBody.Joints</A>.Universal</H2>
<B>Universal joint (2 degrees-of-freedom, used in spanning tree)</B><p>
<IMG SRC="ModelicaAdditions.MultiBody.Joints.UniversalD.gif" ALT="ModelicaAdditions.MultiBody.Joints.Universal">
<H3>Information</H3>
<PRE></PRE>
<p>
Joint where frame_a rotates around axis nx which is fixed in frame_a
and at the same time rotates around axis ny which is fixed in frame_b.
The relative angles revolute1.q, revolute2.q [rad] and the relative
angular velocities revolute1.qd, revolute2.qd [rad/s] are used as
state variables.
</p>

<p>
The following parameters are used to define the joint:
</p>
<pre>
  nx : Axis of rotation 1 resolved in frame_a.
       nx must not necessarily be a unit vector. E.g.,
          nx = {0, 0, 1} or nx = {1, 0, 1}
  ny : Axis of rotation 2 resolved in frame_b.
       ny must not necessarily be a unit vector. E.g.,
          ny = {0, 0, 1} or ny = {1, 0, 1}
  qx0: Rotation angle offset 1 in [deg].
  qy0: Rotation angle offset 2 in [deg].
       If revolute1.q=qx0 and revolute2.q=qy0,
       frame_a and frame_b are identical.
  startValueFixed: true, if start values of q, qd are fixed.
</pre>
<PRE>

</PRE>
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>nx[3]</TD><TD>{1,0,0}</TD><TD>Axis of revolute joint 1 resolved in frame_a</TD></TR>
<TR><TD>ny[3]</TD><TD>{0,1,0}</TD><TD>Axis of revolute joint 2 resolved in frame_b</TD></TR>
<TR><TD>qx0</TD><TD>0</TD><TD>Rotation angle offset in direction of nx (see info) in [deg]</TD></TR>
<TR><TD>qy0</TD><TD>0</TD><TD>Rotation angle offset in direction of ny (see info) in [deg]</TD></TR>
<TR><TD>startValueFixed</TD><TD>false</TD><TD>true, if start values of q, qd are fixed</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
model Universal
  &quot;Universal joint (2 degrees-of-freedom, used in spanning tree)&quot;
  extends <A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces.TwoTreeFrames"
>MultiBody.Interfaces.TwoTreeFrames</A>;
  parameter Real nx[3]={1,0,0}
    &quot;Axis of revolute joint 1 resolved in frame_a&quot;;
  parameter Real ny[3]={0,1,0}
    &quot;Axis of revolute joint 2 resolved in frame_b&quot;;
  parameter Real qx0=0
    &quot;Rotation angle offset in direction of nx (see info) in [deg]&quot;;
  parameter Real qy0=0
    &quot;Rotation angle offset in direction of ny (see info) in [deg]&quot;;
  parameter Boolean startValueFixed=false
    &quot;true, if start values of q, qd are fixed&quot;;
  <A HREF="ModelicaAdditions_MultiBody_Joints.html#ModelicaAdditions.MultiBody.Joints.Revolute"
>MultiBody.Joints.Revolute</A> revolute1(
    n=nx,
    q0=qx0,
    startValueFixed=startValueFixed);
  <A HREF="ModelicaAdditions_MultiBody_Joints.html#ModelicaAdditions.MultiBody.Joints.Revolute"
>MultiBody.Joints.Revolute</A> revolute2(
    n=ny,
    q0=qy0,
    startValueFixed=startValueFixed);
equation
  connect(frame_a, revolute1.frame_a);
  connect(revolute2.frame_b, frame_b);
  connect(revolute1.frame_b, revolute2.frame_a);
end Universal;
</PRE>
<HR>
<H2><IMG SRC="ModelicaAdditions.MultiBody.Joints.PlanarI.gif" ALT="ModelicaAdditions.MultiBody.Joints.Planar" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="ModelicaAdditions.MultiBody.Joints.Planar"></A><A HREF="ModelicaAdditions_MultiBody_Joints.html#ModelicaAdditions.MultiBody.Joints"
>ModelicaAdditions.MultiBody.Joints</A>.Planar</H2>
<B>Planar joint (3 degrees-of-freedom, used in spanning tree)</B><p>
<IMG SRC="ModelicaAdditions.MultiBody.Joints.PlanarD.gif" ALT="ModelicaAdditions.MultiBody.Joints.Planar">
<H3>Information</H3>
<PRE></PRE>
<p>
Joint where frame_b can move in a plane and can rotation around an
axis perpendicular to the plane. The plane is defined by
vector n which is perpendicular to the plane and by vector nx,
which points in the direction of the x-axis of the plane.
The relative distances prismatic1.q, prismatic2.q [m] and
the relative rotation angle revolute.q [rad], as well as
the relative velocities prismatic1.qd, prismatic1.qd [m/s],
and the relative angular velocity revolute.qd [rad/s]
are used as state variables.
</p>

<p>
The following parameters are used to define the joint:
</p>
  n    : Axis perpendicular to plane resolved in frame_a (= same as in frame_b)
         n must not necessarily be a unit vector. E.g.,
            n = {0, 0, 1} or n = {1, 0, 1}
  qx0  : If prismatic1.q0=qx0, prismatic2.q0=qy0 and
  qy0    revolute.q=qr0, frame_a and frame_b are identical.
  qr0
  startValueFixed: true, if start values of q, qd are fixed.
</pre>
<PRE>
</PRE>
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>n[3]</TD><TD>{0,0,1}</TD><TD>Axis perpendicular to plane resolved in frame_a (= same as in frame_b)</TD></TR>
<TR><TD>nx[3]</TD><TD>{1,0,0}</TD><TD>x-translation axis resolved in frame_a</TD></TR>
<TR><TD>qx0</TD><TD>0</TD><TD>Distance offset in nx direction (see info) [m]</TD></TR>
<TR><TD>qy0</TD><TD>0</TD><TD>Distance offset in ny direction (see info) [m]</TD></TR>
<TR><TD>qr0</TD><TD>0</TD><TD>Rotation angle offset (see info) in [deg]</TD></TR>
<TR><TD>startValueFixed</TD><TD>false</TD><TD>true, if start values of q, qd are fixed</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
model Planar
  &quot;Planar joint (3 degrees-of-freedom, used in spanning tree)&quot;
  extends <A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces.TwoTreeFrames"
>MultiBody.Interfaces.TwoTreeFrames</A>;
  parameter Real n[3]={0,0,1}
    &quot;Axis perpendicular to plane resolved in frame_a (= same as in frame_b)&quot;
    ;
  parameter Real nx[3]={1,0,0}
    &quot;x-translation axis resolved in frame_a&quot;;
  parameter SIunits.Position qx0=0
    &quot;Distance offset in nx direction (see info)&quot;;
  parameter SIunits.Position qy0=0
    &quot;Distance offset in ny direction (see info)&quot;;
  parameter Real qr0=0 &quot;Rotation angle offset (see info) in [deg]&quot;;
  parameter Boolean startValueFixed=false
    &quot;true, if start values of q, qd are fixed&quot;;
  <A HREF="ModelicaAdditions_MultiBody_Joints.html#ModelicaAdditions.MultiBody.Joints.Prismatic"
>MultiBody.Joints.Prismatic</A> prismatic1(
    n=(cross(cross(n, nx), n)),
    q0=qx0,
    startValueFixed=startValueFixed);
  <A HREF="ModelicaAdditions_MultiBody_Joints.html#ModelicaAdditions.MultiBody.Joints.Prismatic"
>MultiBody.Joints.Prismatic</A> prismatic2(
    n=(cross(n, nx)),
    q0=qy0,
    startValueFixed=startValueFixed);
  <A HREF="ModelicaAdditions_MultiBody_Joints.html#ModelicaAdditions.MultiBody.Joints.Revolute"
>MultiBody.Joints.Revolute</A> revolute(
    n=n,
    q0=qr0,
    startValueFixed=startValueFixed);
equation
  connect(frame_a, prismatic1.frame_a);
  connect(prismatic1.frame_b, prismatic2.frame_a);
  connect(prismatic2.frame_b, revolute.frame_a);
  connect(revolute.frame_b, frame_b);
end Planar;
</PRE>
<HR>
<H2><IMG SRC="ModelicaAdditions.MultiBody.Joints.SphericalI.gif" ALT="ModelicaAdditions.MultiBody.Joints.Spherical" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="ModelicaAdditions.MultiBody.Joints.Spherical"></A><A HREF="ModelicaAdditions_MultiBody_Joints.html#ModelicaAdditions.MultiBody.Joints"
>ModelicaAdditions.MultiBody.Joints</A>.Spherical</H2>
<B>Spherical joint described by three Cardan angles (3 degrees-of-freedom, used in spanning tree)</B><p>
<IMG SRC="ModelicaAdditions.MultiBody.Joints.SphericalD.gif" ALT="ModelicaAdditions.MultiBody.Joints.Spherical">
<H3>Information</H3>
<PRE></PRE>
<p>
Joint where the origins of frame_a and frame_b always coincide, and
the frames are rotating against each other. The joint is realized in
such a way, that a singularity cannot occur. This is achieved because
the Cardan angles are defined between a frame_fix fixed in frame_a and
frame_b. Whenever the Cardan angles are near a singularity, the
integration is stopped and frame_fix is changed, such that the Cardan
angles are far away from the singularity. The following state
variables are used:
</p>

<pre>
  phi[3]   : Cardan angles, also called Tait-Bryan angles, i.e.,
             rotate around 1-, 2-, 3-axis in [rad] from intermediate
             frame_fix, which is fixed in frame_a, to frame_b. Initially, frame_fix
             is identical to frame_a. If phi[2] is near its singularity (= pi/2 or -pi/2),
             the frame_fix and phi are changed, such that phi[2] is far away from
             its singularity.
  w_rela[3]: Relative angular velocity of frame_b with respect to frame_a
             resolved in frame_a in [rad/s].
</pre>
<PRE></PRE>
<H3>Modelica definition</H3>
<PRE>
model Spherical
  &quot;Spherical joint described by three Cardan angles (3 degrees-of-freedom, used in spanning tree)&quot;

  <I></I>

    <I>// S_rel needs a correct start value, because pre(S_rel) is referenced below</I>
  extends <A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces.TreeJoint"
>MultiBody.Interfaces.TreeJoint</A>(S_rel(start=identity(3)));
  SIunits.Angle phi[3](fixed={true,true,true})
    &quot;Cardan angles from a frame fixed in frame_a to frame_b&quot;;
  <I></I>
protected
  constant Real phi2_critical_deg=80
    &quot;angle in [deg] too close to singularity. Redefine S_fix and phi&quot;
    ;
  constant Real phi2_critical=phi2_critical_deg*Modelica.Constants.pi/180.0;
  constant Real c2_small=1.e-5
    &quot;if cos(phi[2]) &lt; c2_small, c2_small is used as guard against zero division&quot;
    ;
  Real s1;
  Real s2;
  Real s3;
  Real c1;
  Real c2;
  Real c2a;
  Real c3;
  Boolean switch_state;
  Real S_phi[3, 3] &quot;S_rel = S_phi(phi)*S_fix&quot;;
  discrete Real S_fix[3, 3](start=identity(3))
    &quot;S_rel = S_phi(phi)*S_fix&quot;;
  SIunits.AngularVelocity w_fix[3]
    &quot;Relative angular velocity resolved in intermediate frame S_fix&quot;;
equation
  <I>/* Determine sines and cosines of the Cardan angles */</I>
  s1 = Modelica.Math.sin(phi[1]);
  s2 = Modelica.Math.sin(phi[2]);
  s3 = Modelica.Math.sin(phi[3]);
  c1 = Modelica.Math.cos(phi[1]);
  c2a = Modelica.Math.cos(phi[2]);
  c3 = Modelica.Math.cos(phi[3]);
  <I></I>
  <I>/* Below, some expressions are divided by c2. By construction, it is not possible
     that c2=0, during continuous simulation. However, at initial time and when
     large numerical errors occur, c2=0 is possible, which would result in a division
     by zero. The following statement is a guard against this unlikely situation.
  */</I>
  c2 = if noEvent(c2a &gt; c2_small or c2a &lt; -c2_small) then c2a else if
    noEvent(c2a &gt;= 0) then c2_small else -c2_small;
  <I></I>
  <I>/* Relative transformation matrix
       S_phi = [ c3, s3, 0;
                -s3, c3, 0;
                  0, 0, 1]*[c2, 0, -s2;
                             0, 1, 0;
                            s2, 0, c2]*[1, 0, 0;
                                        0, c1, s1;
                                        0, -s1, c1];
  */</I>
  switch_state = phi[2] &gt;= phi2_critical or phi[2] &lt;= -phi2_critical;
  when switch_state then
    S_fix = pre(S_rel);
    reinit(phi, zeros(3));
  end when;
  S_phi = [c2*c3, c1*s3 + s1*s2*c3, s1*s3 - c1*s2*c3; -c2*s3, c1*c3 - s1*s2*s3
    , s1*c3 + c1*s2*s3; s2, -s1*c2, c1*c2];
  S_rel = S_phi*S_fix;
  <I></I>
  <I>// No translational movement</I>
  r_rela = zeros(3);
  v_rela = zeros(3);
  a_rela = zeros(3);
  <I></I>
  <I>// Kinematic differential equations for rotational motion    </I>
  w_fix = S_fix*w_rela;
  der(phi) = {w_fix[1] + (s1*w_fix[2] - c1*w_fix[3])*s2/c2,c1*w_fix[2] + s1*
    w_fix[3],(-s1*w_fix[2] + c1*w_fix[3])/c2};
  der(w_rela) = z_rela;
  <I></I>
  <I>// Kinematic relationships</I>
  frame_b.S = frame_a.S*transpose(S_rel);
  frame_b.r0 = frame_a.r0;
  <I></I>
  frame_b.v = S_rel*frame_a.v;
  frame_b.w = S_rel*(frame_a.w + w_rela);
  <I></I>
  frame_b.a = S_rel*frame_a.a;
  frame_b.z = S_rel*(frame_a.z + cross(frame_a.w, w_rela) + z_rela);
  <I></I>
  <I>// cut-torques are zero</I>
  frame_a.f = -transpose(S_rel)*frame_b.f;
  frame_a.t = zeros(3);
  frame_b.t = zeros(3);
end Spherical;
</PRE>
<HR>
<H2><IMG SRC="ModelicaAdditions.MultiBody.Joints.FreeMotionI.gif" ALT="ModelicaAdditions.MultiBody.Joints.FreeMotion" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="ModelicaAdditions.MultiBody.Joints.FreeMotion"></A><A HREF="ModelicaAdditions_MultiBody_Joints.html#ModelicaAdditions.MultiBody.Joints"
>ModelicaAdditions.MultiBody.Joints</A>.FreeMotion</H2>
<B>Free motion joint (6 degrees-of-freedom, used in spanning tree)</B><p>
<IMG SRC="ModelicaAdditions.MultiBody.Joints.FreeMotionD.gif" ALT="ModelicaAdditions.MultiBody.Joints.FreeMotion">
<H3>Information</H3>
<PRE></PRE>
<p>
Joint which does not constrain the motion between frame_a and frame_b.
Such a joint is just used to define the desired states to be used.
The joint is realized in
such a way, that a singularity cannot occur. This is achieved because
the Cardan angles are defined between a frame_fix fixed in frame_a and
frame_b. Whenever the Cardan angles are near a singularity, the
integration is stopped and frame_fix is changed, such that the Cardan
angles are far away from the singularity. The following state
variables are used:
</p>

<pre>
  r_rela[3]: Distance vector from the origin of frame_a to the origin
             of frame_b, resolved in frame_a in [m].
  phi[3]   : Cardan angles, also called Tait-Bryan angles, i.e.,
             rotate around 1-, 2-, 3-axis in [rad] from intermediate
             frame_fix, which is fixed in frame_a, to frame_b. Initially, frame_fix
             is identical to frame_a. If phi[2] is near its singularity (= pi/2 or -pi/2),
             the frame_fix and phi are changed, such that phi[2] is far away from
             its singularity.
  v_rela[3]: = der(r_rela); relative velocity of frame_b with respect to frame_a
             resolved in frame_a in [m/s].
  w_rela[3]: Relative angular velocity of frame_b with respect to frame_a
             resolved in frame_a in [rad/s].
</pre>
<PRE>
</PRE>
<H3>Modelica definition</H3>
<PRE>
model FreeMotion
  &quot;Free motion joint (6 degrees-of-freedom, used in spanning tree)&quot;
  <I></I>

    <I>// S_rel needs a correct start value, because pre(S_rel) is referenced below</I>
  extends <A HREF="ModelicaAdditions_MultiBody_Interfaces.html#ModelicaAdditions.MultiBody.Interfaces.TreeJoint"
>MultiBody.Interfaces.TreeJoint</A>(S_rel(start=identity(3)));
  SIunits.Angle phi[3]
    &quot;Cardan angles from a frame fixed in frame_a to frame_b&quot;;
protected
  constant Real phi2_critical_deg=80
    &quot;angle in [deg] too close to singularity. Redefine S_fix and phi&quot;
    ;
  constant Real phi2_critical=phi2_critical_deg*Modelica.Constants.pi/180.0;
  constant Real c2_small=1.e-5
    &quot;if cos(phi[2]) &lt; c2_small, c2_small is used as guard against zero division&quot;
    ;
  SIunits.Velocity vaux[3];
  Real s1;
  Real s2;
  Real s3;
  Real c1;
  Real c2;
  Real c2a;
  Real c3;
  Boolean switch_state;
  Real S_phi[3, 3] &quot;S_rel = S_phi(phi)*S_fix&quot;;
  discrete Real S_fix[3, 3](start=identity(3))
    &quot;S_rel = S_phi(phi)*S_fix&quot;;
  SIunits.AngularVelocity w_fix[3]
    &quot;Relative angular velocity resolved in intermediate frame S_fix&quot;;
  <I></I>
equation
  <I></I>
  <I>/* Determine sines and cosines of the Cardan angles */</I>
  s1 = Modelica.Math.sin(phi[1]);
  s2 = Modelica.Math.sin(phi[2]);
  s3 = Modelica.Math.sin(phi[3]);
  c1 = Modelica.Math.cos(phi[1]);
  c2a = Modelica.Math.cos(phi[2]);
  c3 = Modelica.Math.cos(phi[3]);
  <I></I>
  <I>/* Below, some expressions are divided by c2. By construction, it is not possible
     that c2=0, during continuous simulation. However, at initial time and when
     large numerical errors occur, c2=0 is possible, which would result in a division
     by zero. The following statement is a guard against this unlikely situation.
  */</I>
  c2 = if noEvent(c2a &gt; c2_small or c2a &lt; -c2_small) then c2a else if
    noEvent(c2a &gt;= 0) then c2_small else -c2_small;
  <I></I>
  <I>/* Relative transformation matrix
       S_phi = [ c3, s3, 0;
                -s3, c3, 0;
                  0, 0, 1]*[c2, 0, -s2;
                             0, 1, 0;
                            s2, 0, c2]*[1, 0, 0;
                                        0, c1, s1;
                                        0, -s1, c1];
  */</I>
  switch_state = phi[2] &gt;= phi2_critical or phi[2] &lt;= -phi2_critical;
  when switch_state then
    S_fix = pre(S_rel);
    reinit(phi, zeros(3));
  end when;
  S_phi = [c2*c3, c1*s3 + s1*s2*c3, s1*s3 - c1*s2*c3; -c2*s3, c1*c3 - s1*s2*s3
    , s1*c3 + c1*s2*s3; s2, -s1*c2, c1*c2];
  S_rel = S_phi*S_fix;
  <I></I>
  <I>// Kinematic differential equations for translational motion</I>
  der(r_rela) = v_rela;
  der(v_rela) = a_rela;
  <I></I>
  <I>// Kinematic differential equations for rotational motion    </I>
  w_fix = S_fix*w_rela;
  der(phi) = {w_fix[1] + (s1*w_fix[2] - c1*w_fix[3])*s2/c2,c1*w_fix[2] + s1*
    w_fix[3],(-s1*w_fix[2] + c1*w_fix[3])/c2};
  der(w_rela) = z_rela;
  <I></I>
  <I>// Kinematic relationships</I>
  frame_b.S = frame_a.S*transpose(S_rel);
  frame_b.r0 = frame_a.r0 + frame_a.S*r_rela;
  <I></I>
  vaux = cross(frame_a.w, r_rela);
  frame_b.v = S_rel*(frame_a.v + v_rela + vaux);
  frame_b.w = S_rel*(frame_a.w + w_rela);
  <I></I>
  frame_b.a = S_rel*(frame_a.a + cross(frame_a.z, r_rela) + cross(frame_a.w,
    vaux + 2*v_rela) + a_rela);
  frame_b.z = S_rel*(frame_a.z + cross(frame_a.w, w_rela) + z_rela);
  <I></I>
  <I>// cut-forces and cut-torques are zero</I>
  frame_a.f = zeros(3);
  frame_a.t = zeros(3);
  frame_b.f = zeros(3);
  frame_b.t = zeros(3);
end FreeMotion;
</PRE>
<HR>
<address>HTML-documentation generated by <a href="http://www.dynasim.se/">Dymola</a> Tue Jun 20 22:17:30 2000
.
</address></BODY>
</HTML>
